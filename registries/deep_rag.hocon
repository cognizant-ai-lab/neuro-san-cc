
# Copyright (C) 2023-2025 Cognizant Digital Business, Evolutionary AI.
# All Rights Reserved.
# Issued under the Academic Public License.
#
# You can be released from the terms, and requirements of the Academic Public
# License by purchasing a commercial license.
# Purchase of a commercial license is mandatory for any use of the
# neuro-san SDK Software in commercial settings.
#
# END COPYRIGHT

# The schema specifications for this file are documented here:
# https://github.com/cognizant-ai-lab/neuro-san/blob/main/docs/agent_hocon_reference.md

{
    # Optional metadata describing this agent network
    "metadata": {
        "description": "Demonstartion of Abstract Deep RAG",
        "tags": ["rag"],
    },
    "llm_config": {
        "model_name": "gpt-4o",
    },
    "tools": [
        # This first agent definition is regarded as the "Front Man", which
        # does all the talking to the outside world/client.
        #
        # Some disqualifications from being a front man:
        #   1) Cannot use a CodedTool "class" definition
        #   2) Cannot use a Tool "toolbox" definition
        #
        # Besides the first agent being the front man, these tool definitions
        # do not have to be in any particular order. How they are linked and
        # call each other is defined within their own specs.
        # This could be a graph, potentially even with cycles.
        {
            "name": "deep_rag",

            # Note that there are no parameters defined for this guy's "function" key.
            # This is the primary way to identify this tool as a front-man,
            # distinguishing it from the rest of the tools.

            "function": {

                # The description acts as an initial prompt.
                "description": """
Give me a list of .txt files and I will create a Deep RAG
multi-agent network for you for deep insights into the text
beyond what regular RAG can do.

Good, consistent naming of the .txt files can help in defining a high-level
structure for the resulting agent network, and the order in which files
are presented can matter to the creation of the resulting network.
Any one file name should be descriptive enough to aid in proposing high-level
structure for the resulting network.

Providing some hints as to how you have structured the file names will also help.
"""
            },

            "instructions": """
1.  Take the list of file names given in the text and send them to the top_level_structure
    tool to determine the high-level structure for the resulting network.

2.  Return the JSON description of how the files should be grouped at a high-level.
""",
            "tools": ["top_level_structure"]
        },

        {
            "name": "top_level_structure",
            "function": {
                "description": """
""",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "file_list": {
                            "type": "array",
                            "description": """
A list of file names that together contains the content to explore.
The order of these file names can matter.
""",
                            "items": {
                                "type": "string"
                            }
                        },
                        "user_description": {
                            "type": "string",
                            "description": """
This is a description of how the individual files in the file_list might be organized.
"""
                        }
                    }
                },
            },
            "instructions": """
Examine the names of the files in the file_list and take into account any user_description
of the file naming structure to come up with a JSON structure
which describes the following:
* A short "name" for the overall strategy for the grouping
* A "description" of the overall strategy for how the files are to be grouped
* A "groups" list which contains one JSON entry for each of the groups, each entry of which has:
    1. A short "name" for the group which is unique and is the primary reference to the group
    2. A "description" of the group and how it is unique from the other groups.
    3. A "files" list that contains each of the files that belong in the group.

Constraints:
* Each and every file in the file_list must be represented in
  at least one group.
* Any single group may have at least one, but never more than 7 files in it.

Output the JSON structure described.
""",
            # "tools": ["top_level_structure"]
        }
    ]
}
